""" This file implements two methods for the computation of Internation Roughness Index (IRI).
    The file can be either imported and the methods accessed by calling the function iri()
    or can be used as a commandline tool. To get the description of all commandline parameters, call
    python iri.py -h.    
"""
import numpy as np
from math import factorial, sin, cos, exp
from scipy import interpolate
import argparse
import os

def fintM(t1,t2,y1,y2):
    #    fintM
    #
    #    This function was generated by the Symbolic Math Toolbox version 8.1.
    #    24-May-2018 13:37:03

    t4 = t1*2.040992621332219e1
    t5 = exp(t4)
    t6 = t1*6.442262610541198e1
    t7 = t2*2.040992621332219e1
    t8 = exp(t7)
    t9 = t2*6.442262610541198e1
    t10 = cos(t6)
    t11 = t1-t2
    t12 = 1.0/t11
    t13 = cos(t9)
    t14 = sin(t6)
    t15 = sin(t9)
    t16 = t1*2.590073786677789
    t17 = exp(t16)
    t18 = t1*7.323397385729718
    t19 = t2*2.590073786677789
    t20 = exp(t19)
    t21 = t2*7.323397385729718
    t22 = sin(t18)
    t23 = sin(t21)
    t24 = cos(t18)
    t25 = cos(t21)
    iMy = np.vstack([t5*t10*y1*(-8.023278807758917e-1)-t5*t14*y1*6.760740228704583e1+t8*t13*y1*8.023278807758917e-1+t8*t15*y1*6.760740228704583e1-t5*t10*t12*y1*9.501254908070717e-1+t5*t10*t12*y2*9.501254908070717e-1+t5*t12*t14*y1*3.134662503279774e-1-t5*t12*t14*y2*3.134662503279774e-1+t8*t12*t13*y1*9.501254908070717e-1-t8*t12*t13*y2*9.501254908070717e-1-t8*t12*t15*y1*3.134662503279774e-1+t8*t12*t15*y2*3.134662503279774e-1-t1*t8*t12*t13*y1*8.023278807758917e-1+t1*t8*t12*t13*y2*8.023278807758917e-1+t2*t8*t12*t13*y1*8.023278807758917e-1-t1*t8*t12*t15*y1*6.760740228704583e1-t2*t8*t12*t13*y2*8.023278807758917e-1+t1*t8*t12*t15*y2*6.760740228704583e1+t2*t8*t12*t15*y1*6.760740228704583e1-t2*t8*t12*t15*y2*6.760740228704583e1,
                     t5*t10*y1*6.760740228704583e1-t5*t14*y1*8.023278807758917e-1-t8*t13*y1*6.760740228704583e1+t8*t15*y1*8.023278807758917e-1-t5*t10*t12*y1*3.134662503279774e-1+t5*t10*t12*y2*3.134662503279774e-1-t5*t12*t14*y1*9.501254908070717e-1+t5*t12*t14*y2*9.501254908070717e-1+t8*t12*t13*y1*3.134662503279774e-1-t8*t12*t13*y2*3.134662503279774e-1+t8*t12*t15*y1*9.501254908070717e-1-t8*t12*t15*y2*9.501254908070717e-1+t1*t8*t12*t13*y1*6.760740228704583e1-t1*t8*t12*t13*y2*6.760740228704583e1-t2*t8*t12*t13*y1*6.760740228704583e1-t1*t8*t12*t15*y1*8.023278807758917e-1+t2*t8*t12*t13*y2*6.760740228704583e1+t1*t8*t12*t15*y2*8.023278807758917e-1+t2*t8*t12*t15*y1*8.023278807758917e-1-t2*t8*t12*t15*y2*8.023278807758917e-1,
                     t17*t22*y1*(-6.843274120037415)+t17*t24*y1*5.58745119585928+t20*t23*y1*6.843274120037415-t20*t25*y1*5.58745119585928-t12*t17*t22*y1*3.843934011732957e-1+t12*t17*t22*y2*3.843934011732957e-1-t12*t17*t24*y1*1.070388643317791+t12*t17*t24*y2*1.070388643317791+t12*t20*t23*y1*3.843934011732957e-1-t12*t20*t23*y2*3.843934011732957e-1+t12*t20*t25*y1*1.070388643317791-t12*t20*t25*y2*1.070388643317791-t1*t12*t20*t23*y1*6.843274120037415+t1*t12*t20*t23*y2*6.843274120037415+t2*t12*t20*t23*y1*6.843274120037415+t1*t12*t20*t25*y1*5.58745119585928-t2*t12*t20*t23*y2*6.843274120037415-t1*t12*t20*t25*y2*5.58745119585928-t2*t12*t20*t25*y1*5.58745119585928+t2*t12*t20*t25*y2*5.58745119585928,
                     t17*t22*y1*5.58745119585928+t17*t24*y1*6.843274120037415-t20*t23*y1*5.58745119585928-t20*t25*y1*6.843274120037415-t12*t17*t22*y1*1.070388643317791+t12*t17*t22*y2*1.070388643317791+t12*t17*t24*y1*3.843934011732957e-1-t12*t17*t24*y2*3.843934011732957e-1+t12*t20*t23*y1*1.070388643317791-t12*t20*t23*y2*1.070388643317791-t12*t20*t25*y1*3.843934011732957e-1+t12*t20*t25*y2*3.843934011732957e-1+t1*t12*t20*t23*y1*5.58745119585928-t1*t12*t20*t23*y2*5.58745119585928-t2*t12*t20*t23*y1*5.58745119585928+t1*t12*t20*t25*y1*6.843274120037415+t2*t12*t20*t23*y2*5.58745119585928-t1*t12*t20*t25*y2*6.843274120037415-t2*t12*t20*t25*y1*6.843274120037415+t2*t12*t20*t25*y2*6.843274120037415])
    return iMy
    
def fM(t):
    #fM
    #
    #    function M = fM(t)
    #
    #    This function was generated by the Symbolic Math Toolbox version 8.1.
    #    24-May-2018 13:37:03

    t2 = t*6.442262610541198e1
    t10 = t*2.040992621332219e1
    t3 = exp(-t10)
    t4 = cos(t2)
    t5 = sin(t2)
    t6 = t*7.323397385729718
    t11 = t*2.590073786677789
    t7 = exp(-t11)
    t8 = cos(t6)
    t9 = sin(t6)
    M = np.vstack([-t3*(t4*1.009488570317789e-3+t5*8.315147588488827e-4),-t3*(t4*3.296477717707572e-2-t5*8.200505959666402e-2),-t3*(t4*4.45117663500498e-3-t5*1.404985422724839e-2),t3*t4*9.959766924004811e-1,t3*(t4*8.315147588488827e-4-t5*1.009488570317789e-3),-t3*(t4*8.200505959666402e-2+t5*3.296477717707572e-2),-t3*(t4*1.404985422724839e-2+t5*4.45117663500498e-3),t3*t5*9.959766924004811e-1,-t7*(t8*4.238836503712554e-2-t9*1.19852508949723e-1),t7*t8*9.875165438583369e-1,t7*(t8*4.057897959535129e-3+t9*1.115993043207963e-2),t7*(t8*7.121835021721261e-2-t9*5.862264258169474e-2),-t7*(t8*1.19852508949723e-1+t9*4.238836503712554e-2),t7*t9*9.875165438583369e-1,-t7*(t8*1.115993043207963e-2-t9*4.057897959535129e-3),t7*(t8*5.862264258169474e-2+t9*7.121835021721261e-2)]).reshape((4,4))
    return M.transpose()

parser = argparse.ArgumentParser(description=__doc__)
parser.add_argument("input_file", type=str, 
    help="Name of the input file containing road profile. The file is a two-column ASCII file, the first column containing distance, the second elevation (height). Columns are separated by space or any delimiter set by -delimiter.")
parser.add_argument("-delimiter", type=str, default=" ", help = "Delimiter used in the input file. If missing, set to the space character.")
parser.add_argument("-skip_header", type=int, default=0, help = "Number of header lines to skip in the input file. If missing, set to zero.")
parser.add_argument("-plot_file", type=str, help = "Name of the output IRI plot file. If missing, the file is not created. The file format is inferred from its extension, typically pdf, svg or png. For available formats, see the matplotlib savefig function.")
parser.add_argument("iri_file", type=str, 
    help="Name of the output IRI file. The file is a four-column ASCII file with columns" +
        " [star_pos, end_pos, IRI, std_of_IRI], where std_of_IRI is the standard deviation of IRI within each segment," + 
        " IRI is in mm/m (equivalent to m/km). The file keeps the delimiter of the input file.")
parser.add_argument("-segment_length", type=float, default=20, help="Length of the IRI segment (typically 20 or 100 meters). If missing, set to 20m.")
parser.add_argument("-start_pos", type= float, default=-1, help = "Starting position of IRI segments. If empty, set to the first sample.")
parser.add_argument("-step", type= float, default=0, help = "If missing or 0, IRI is computed in non-overlapping segments. Otherwise, this is the shift of consecutive IRI segments in meters, often set to sampling step for regular sampling.")
parser.add_argument("-box_filter", action="store_true", help = "If passed, profile is first averaged with a box filter of length 0.25m as recommended in Sayers' paper for sampling intervals shorter than 0.25m to better represent the way in which the tire of a vehicle envelops the ground.")
parser.add_argument("-method", type=int, default=2, choices = [0, 2], help = "0 - Sayers' implementation, for irregular sampling first resampled; 2(default) - our semi-analytical solution (Sroubek & Sorel).")

args = parser.parse_args()

def iri(Y, segment_length, start_pos, step, box_filter, method):

    """
        IRI calculate IRI 

            function IRI = iri(Y, segment_length, start_pos, step, box_filter, method)

        Input:
        Y ... road profile, Nx2 vector [x,y], both x and y must be in meters.
        segment_length ... length of the IRI segment (typically 20 or 100 meters)
        start_pos ... starting position of IRI segments, if empty, set to the first sample
        step ... if empty or 0, IRI is computed in segments without overlap
                      otherwise, the step is the shift of consecutive IRI segments (can be
                      set for example to sampling step for regular profile sampling);
                      step cannot be logical true.
        box_filter ... true/false (impl. value true), if true,
                      profile is first averaged with a box filter of length 0.25m 
                      as recommended in Sayers' paper for sampling intervals
                      shorter than 0.25m to better represent the way in which 
                      the tire of a vehicle envelops the ground.
        method ...    0 - Sayers' implementation, for irregular sampling first resampled                
                      1 - numerical solver ode45 (in Python not implemented),
                      2(default) - our semi-analytical solution (Sroubek & Sorel)

        Output:
        IRI ... IRI vector calculated in segments; matrix with rows
                  [star_pos, end_pos, IRI, std_of_IRI]
                 std_of_IRI is standard deviation of IRI within each segment
        IRI is in mm/m [equivalent to m/km]
    """

    if segment_length == -1:
        segment_length = 20
        print('Parameter segment_length does not exist, set to 20 m.')
    if start_pos == -1:
        print('Parameter start_pos does not exist, set to the first sample.')
        start_pos = Y[0,0]
    overlap = step # old not much logical naming        
    if type(overlap) == bool and overlap == True:
        print('overlap parametr cannot be logical true, must be either false or a number containing overlap size.')
        return

    # basic parameter checks
    if any(np.diff(Y[:,0])<=0):
        print('First column of the first parameter (stationing) should be sorted and non-duplicated.')
        return
    if start_pos < Y[0,0]:
        print('Starting position should be within the sampled profile.')
        return
    if start_pos > Y[-1,0]:
        print('Starting position should be within the sampled profile.')
        return
    if overlap > 0:
        if overlap > segment_length:
            print('Segment overlap must be shorter than segment length.')
            return


    print('========================================')
    print('IRI computation')
    print('----------------------------------------')
    # Standard car parameters
    K1 = 653
    K2 = 63.3
    C = 6
    u = 0.15

    A = np.array([ [0, 1, 0, 0], [-K2, -C, K2, C], [0, 0, 0, 1], [K2/u, C/u, -(K1+K2)/u, -C/u] ])
    b = np.vstack([ 0, 0, 0, K1/u ])

    # standard car speed 80km/h = 22.2m/s
    v = 80/3.6

    # remove duplicated points - should never happen but to be sure
    DX = np.diff(Y[:,0])
    mask = (DX != 0)
    mask = np.hstack((True,mask))
    YC = Y[mask,:]
    DX = DX[DX!=0]
    if np.count_nonzero(mask == False) > 0:
        print('Removing', np.count_nonzero(mask == False), 'duplicated points.')

    # check if data are equidistant
    dx = np.median(DX)
    if np.max(np.absolute(DX - dx)) > dx/1e5:
        print('Data are not equidistant (tolerance 1e-5).');
        equidistant = False
    else:
        print('Regular sampling:', dx, 'm')
        equidistant = True

    # Calculate numerically S and p for Sayers' method
    if method == 0:
        # Default for dx == 0.25cm
        #S = [0.9966071, .01091514, -0.002083274, 0.0003190145;...
        #    -0.5563044, 0.9438768 -0.8324718, 0.05064701; ...
        #    0.02153176, 0.002126763, 0.7508714, 0.008221888; ...
        #    3.335013 , 0.3376467 ,-39.12762, 0.4347564];
        #p = [0.005476107; 1.388776; 0.2275968; 35.79262];
        N = 100
        t = dx/v
        S = np.identity(4)
        tA = A
        for i in range(1,N+1):
            S = S + tA*((t**i)/factorial(i))
            tA = np.matmul(tA,A)
        p = np.linalg.solve(A,np.matmul(S-np.identity(4),b))
        if equidistant == False:
            print('Sayers method for irregular sampling does not work (would take too long).')
            return
        if np.count_nonzero(YC[:,0]==start_pos) == 0:
            print('Starting positions in Sayers method must coincide with input sampling.')
            return

    # average profile with a box filter of length 0.25m as recommended in Sayers' paper,
    # for regular samplings could be implemented much faster by convolution
    if box_filter == True:
        if any(np.diff(YC[:,0])<=0.25/2): # check if necessary
            for i in range(YC.shape[0]):
                YC[i,1] = np.mean(YC[np.logical_and(YC[:,0] >= YC[i,0]-0.25/2, YC[:,0] <= YC[i,0]+0.25/2),1])
        else:
            print('Samples are more than 0.125 m from each other, box filter not needed, skipped...')
    # interpolate all segment lower/upper ends and add them to profile
    end_X = np.arange(start_pos+segment_length,YC[-1,0]+0.001,segment_length)
    ipolated_fun = interpolate.interp1d(YC[:,0],YC[:,1])
    YY = ipolated_fun( np.hstack((start_pos,end_X)) )
    Stack = np.dstack(( np.hstack((start_pos,end_X)), YY ))[0]
    YC = np.vstack((YC,Stack))
    YC = YC[YC[:, 0].argsort()]
    DX = np.diff(YC[:,0])
    mask = (DX != 0)
    mask = np.hstack((True,mask))
    YC = YC[mask,:]
    si = np.where(YC[:,0] == start_pos)[0] # si = index of the beginning of the first segment
    if len(si) == 0:
        print('Assert: unique starting position should always exist at this moment.')
        return
    if overlap == False:    
        end_si = np.where(np.in1d(YC[:,0], end_X) == True)[0]
        start_si = np.hstack((si,end_si[0:-1]))    
        end_si_o = end_si
        start_si_o = start_si
        nsegments = len(end_X)
        nsegments_o = nsegments
    else: # overlapping intervals with step "overlap"
        overlap = float(overlap) # convert to double
        if method == 0 and (overlap % dx) > 0: # overlap must be a multiple of dx 
            print('Sayers method with overlapped segments requires the overlap to be a multiple of the sampling step.')
            return
        start_X_o = np.arange(start_pos,YC[-1,0]-segment_length+0.001,overlap) # lower ends of the segments
        end_X_o = np.arange(start_pos+segment_length,YC[-1,0]+0.001,overlap) # upper ends
        XX = np.union1d(start_X_o,end_X_o)
        ipolated_fun = interpolate.interp1d(YC[:,0],YC[:,1])
        YY = ipolated_fun(XX)
        
         # now including both overlapping and non-overlapping segment boundaries
        Stack = np.dstack(( XX, YY))[0]
        YC = np.vstack((YC,Stack))
        YC = YC[YC[:, 0].argsort()]
        DX = np.diff(YC[:,0])
        mask = (DX != 0)
        mask = np.hstack((True,mask))
        YC = YC[mask,:]   
        
        end_si = np.where(np.in1d(YC[:,0], end_X) == True)[0]
        start_si = np.hstack((si,end_si[0:-1]))     
        start_si_o = np.where(np.in1d(YC[:,0], start_X_o) == True)[0]
        end_si_o = np.where(np.in1d(YC[:,0], end_X_o) == True)[0]
        nsegments = len(end_X)
        nsegments_o = len(end_X_o)
        nsegments_aux = np.ceil((YC[-1,0]-start_pos)/segment_length)
        if ((YC[-1,0]-start_pos) % segment_length) > 0:
            YC = np.vstack((YC, np.hstack((start_pos+nsegments_aux*segment_length, YC[-1,1])) )) # add one dummy sample point
            #dummy = true;
            nsegments = int(nsegments_aux) # increase the number of segments by one
            start_si = np.hstack((start_si,end_si[-1])) # from the end to the dummy point
            end_si = np.hstack(( end_si, YC.shape[0]-1 ))
        #else 
            #dummy = false;

    # MELO BY JIT TEN ZACATEK ODSTRANIT?
    #YC = YC(si:end,:); % overit vsechny dalsi vyskyty, ze to fakt nevadi

    #IRI = zeros(maxs,4);
    #IRI1 = zeros(maxs,4);

    print('Segment length:', segment_length, 'm') 
    print('Starting position:', *YC[si,0], 'm')
    print('Method:', method)
    print('Number of segments:', nsegments_o) 

    # initialization of Z according to the IRI book
    t0 = 0.5
    si = si[0]
    Y = np.hstack((YC[si:,0:1] - YC[si,0:1], YC[si:,1:]))
    Y = np.multiply(Y, np.array([1/v,1000])) 
    y0 = Y[0,1] # [mm]
    Y = np.unique(Y,axis = 0)  # just in case /v create duplicates (not solved in YC for now)
    ipolated_fun = interpolate.interp1d(Y[:,0],Y[:,1], fill_value = 'extrapolate')
    y0p = (ipolated_fun( t0 ) - Y[0,1])/t0 # [mm/s]
    if method == 0:
        z0 = np.hstack((y0p/v, 0, y0p/v, 0))
    else:
        z0 = np.hstack((y0, y0p, y0, y0p))

    if method == 2:
        fM0 = fM(0)

    DD = np.zeros(end_si[-1]-start_si[0]+1)
    # main loop - take profile in segments of length segment_length
    for s in range(nsegments):    
        si = start_si[s]
        ei = end_si[s]
        Y = np.hstack((YC[si:ei+1,0:1]-YC[si,0:1], YC[si:ei+1,1:] )) # set the first point to start at distance 0    
        ft = Y[:,0]/v # convert top view distance along the profile to time for car speed 80km/h 
        #ft = cumsum([0; sqrt(sum(diff(Y).^2,2))])/v # distance along the surface    
        Y[:,1] = Y[:,1]*1000 # convert y to [mm]

        if method == 0: # M.Sayers 
            # resample profile with step dx 
            #X = 0:dx:Y(end,1);
            #Y = [X.', interp1(Y(:,1),Y(:,2),X.')];
            DY = np.diff(Y[:,1])/dx
            Z = np.zeros((Y.shape[0],4))
            Z[0,:] = z0[:]
            for i in range(Y.shape[0]-1):
                Z[i+1,:] = np.transpose(np.matmul(S,Z[i,:])) + (p*DY[i]).reshape(4,)
            D = abs(Z[1:,0]-Z[1:,2])/(segment_length/dx)
            DD[start_si[s]-start_si[0]+1:end_si[s]-start_si[0]+1] = D
#         elif method == 1: # Numerical solver ode45
#             options = odeset('Stats','off', 'AbsTol', 1e-9, 'RelTol', 1e-5);
#             [T,Z] = ode45(@myode, ft, z0, options);
#             X = T*v;
#             D = abs(Z(2:end,2)-Z(2:end,4)).*diff(T)/X(end);
#             DD[start_si[s]-start_si[0]+1:end_si[s]-start_si[0]+1] = D
        elif method == 2: # Semi-analytical solution, Sroubek & Sorel
            Z = np.zeros((Y.shape[0],4))
            Z[0,:] = z0
            iZ = np.linalg.solve(fM0,z0) #iZ = inv(fM0)*z0;
            cS = np.vstack([0, 0, 0, 0])
            for i in range(1,Z.shape[0]):
                if ft[i]-ft[i-1] > 1e-10:                
                    cS = cS + fintM(ft[i-1],ft[i],Y[i-1,1],Y[i,1])
                    if any(np.isnan(cS)):
                        print('Warning: NaN value!')
                    Z[i,:] = np.matmul(fM(ft[i]),iZ + cS.reshape(4,)) 
                else:
                    Z[i,:] = Z[i-1,:] # is it more precise or not?
                    #Z(i,:) = np.matmul(fM(ft[i]),iZ + cS)
            D = np.multiply(np.absolute(Z[1:,1]-Z[1:,3]),np.diff(ft)/Y[-1,0])
            DD[start_si[s]-start_si[0]+1:end_si[s]-start_si[0]+1] = D
        z0 = Z[-1,:] 
    # end of the main loop
    IRI = np.zeros((nsegments_o,4))
    for s in range(nsegments_o):
        IRI[s,0:2] = np.hstack([YC[start_si_o[s],0], YC[end_si_o[s],0]])
        IRI[s,2] = np.sum(DD[start_si_o[s]-start_si_o[0]+1:end_si_o[s]-start_si_o[0]+1])
        IRI[s,3] = np.std(DD[start_si_o[s]-start_si_o[0]+1:end_si_o[s]-start_si_o[0]+1])*(end_si_o[s]-start_si_o[s])
    return IRI, equidistant

import matplotlib.pyplot as plt
def plot_iri(IRI,YC, title, plot_file):
#   PLOT_IRI IRI plot
#
#   function plot_iri(IRI,YC)
#
#   IRI ... output of iri function
#   YC ... input profile of the iri function

    fig, ax1 = plt.subplots()
    ax2 = ax1.twinx()
    lns1 = ax1.plot((IRI[:,0]+IRI[:,1])/2, IRI[:,2], '-b', label = 'IRI')
    lns2 = ax2.plot(YC[:,0], YC[:,1], '-r', label = 'Road profile')
    ax1.set_xlabel('Stationing [m]')
    ax1.set_ylabel('IRI [mm/m]', color='b')
    ax2.set_ylabel('Elevation [m]', color='r')
    ax1.set(title=title)
    ax1.xaxis.label.set_size(20)
    ax1.yaxis.label.set_size(20)
    ax2.yaxis.label.set_size(20)
    fig.set_size_inches(18.5, 10.5)
    lns = lns1+lns2
    labs = [l.get_label() for l in lns]
    ax1.legend(lns, labs)
    plt.savefig(plot_file)

if __name__ == "__main__":   
    road_profile = np.genfromtxt(args.input_file, delimiter=args.delimiter, skip_header=args.skip_header)
    Solution, equidistant = iri(road_profile, args.segment_length, args.start_pos, args.step, args.box_filter, args.method)
    output_folder = os.path.dirname(args.iri_file)
    if not output_folder:
        output_folder = '.'
    else:
        if not os.path.exists(output_folder):
            os.mkdir(output_folder)
    np.savetxt(args.iri_file,Solution,fmt = '%s', 
        header = 'Start, End, IRI value, IRI std. deviation', delimiter = args.delimiter)
    if args.method == 0:
        title = 'Sayers'
    else:
        title = 'Sorel & Sroubek'
    if equidistant:
        title += ', regular sampling'
    else:
        title += ', irregular sampling'
    title += ', segment length {}m'.format(args.segment_length)        
    if args.step:
        title += ', step {}m'.format(args.step)
    if args.plot_file:    
        plot_iri(Solution, road_profile, title, args.plot_file)